import { Edge, Node } from "@xyflow/react";
import { NodeType } from "../render/components/react-flow/ReactFlowCanvas";

const defintions: Record<NodeType, () => string> = {
  Button: defineButton,
  Counter: defineCounter,
  Interval: defineInterval,
  Led: defineLed,
  Figma: () => ``
}

export function generateCode(nodes: Node[], edges: Edge[]) {
  let code = `
/*
 * This code was generated by Figma hardware bridge.
 *
 * No warranty is provided.
 */
`

  code += addImports()

  let innerCode = ``

  innerCode += addBoard()

  const boardListners = ["error", "fail", "warn", "exit", "close", "info"]
  boardListners.forEach((listener) => {
    innerCode += addBoardListener(listener)
  })

  innerCode += addBoardListener("ready", false)

  nodes.forEach((node) => {
    innerCode += `  ${createNode(node)}`
    innerCode += addEnter()
  })
  innerCode += addEnter()

  const nodesWithActionListener = nodes.filter(node => edges.some((edge) => edge.source === node.id))

  nodesWithActionListener.forEach((node) => {
    const actions = edges.filter((edge) => edge.source === node.id);

    const actionsGroupedByHandle = actions.reduce(
      (acc, action) => {
        if (!acc[action.sourceHandle]) {
          acc[action.sourceHandle] = [];
        }

        acc[action.sourceHandle].push(action);

        return acc;
      },
      {} as Record<string, Edge[]>,
    );

    Object.entries(actionsGroupedByHandle).forEach(([action, edges]) => {
      innerCode += `  ${node.type}_${node.id}.on("${action}", () => {`
      innerCode += addEnter()

      edges.forEach((edge) => {
        const targetNode = nodes.find((node) => node.id === edge.target);
        innerCode += `    ${targetNode?.type}_${targetNode?.id}.${edge.targetHandle}(${edge.data ? JSON.stringify(edge.data) : ""});`
        innerCode += addEnter()
      })

      innerCode += `  }); // ${node.type}_${node.id} - ${action}`
      innerCode += addEnter()
      innerCode += addEnter()
    })
  })

  innerCode += `}); // board - ready`

  code += wrapInTryCatch(innerCode)

  Object.keys(defintions).forEach((type) => {
    if (!nodes.find(node => node.type === type)) {
      return
    }

    code += addEnter()
    code += defintions[type as NodeType]()
  })

  return code
}

function addEnter() {
  return `
`
}

function addImports() {
  return `
const EventEmitter = require("events");
const JohnnyFive = require("johnny-five");
const log = require("electron-log/node");
`
}

function addBoard() {
  return `
const board = new JohnnyFive.Board({
  repl: false,
  debug: false,
});
`
}

function addBoardListener(type: string, selfClosing = true) {
  return `
board.on("${type}", (event) => {
  log.warn("board ${type}", { event });
  process.parentPort.postMessage({ type: "${type}", message: event?.message });
${selfClosing ? `}); // board - ${type}` : ``}
`
}

function wrapInTryCatch(code: string) {
  return `
try {
  ${code}
} catch(error) {
  log.error("something went wrong", { error });
}
`
}

function createNode(node: Node) {
  node.data.id = node.id;

  switch (node.type as NodeType) {
    case "Button":
    case "Led":
    case "Counter":
    case "Interval":
      return `const ${node.type}_${node.id} = new ${node.type}(${JSON.stringify(node.data)});`;
    default:
      console.warn(`Unknown node type: ${node.type}`);
      return ``;
  }
}

function defineButton() {
  return `
class Button extends JohnnyFive.Button {
  get value() {
    return this.value;
  }

  constructor(options) {
    super(options);

    this.on("up", this.#postMessage.bind(this, "up"));
    this.on("down", this.#postMessage.bind(this, "down"));
    this.on("hold", this.#postMessage.bind(this, "hold"));
    this.on("change", this.#postMessage.bind(this, "change"));
  }

  #postMessage(action) {
    if (action !== "change") {
      this.emit("change", this.value);
    }

    process.parentPort.postMessage({
      nodeId: this.id,
      action,
      value: this.value,
    });
  }
}
`
}

function defineLed() {
  return `
class Led extends JohnnyFive.Led {
  #previousValue = 0;
  #eventEmitter = new EventEmitter();

  constructor(options) {
    super(options);

    setInterval(() => {
      if (this.#previousValue !== this.value) {
        this.#eventEmitter.emit("change");
        if(this.value !== null) {
          this.#postMessage("change");
        }
      }

      this.#previousValue = this.value;
    }, 25);
  }

  on(action, callback) {
    if (!action) {
      super.on();
      this.#postMessage("on");
      return;
    }

    this.#eventEmitter.on(action, callback);
  }

  off() {
    super.off();
    this.#postMessage("off");
  }

  toggle() {
    super.toggle();
    this.#postMessage("toggle");
  }

  #postMessage(action) {
    process.parentPort.postMessage({ nodeId: this.id, action, value: this.value });
  }
}
`
}

function defineCounter() {
  return `
class Counter extends EventEmitter {
  #count = 0;
  id = null;

  constructor(options) {
    super();

    this.id = options.id;
  }

  set count(value) {
    this.#count = value;
    this.emit("change", value);
    process.parentPort.postMessage({ nodeId: this.id, action: "change", value });
  }

  get count() {
    return this.#count;
  }

  increment(amount = 1) {
    this.count += parseInt(amount);
    process.parentPort.postMessage({ nodeId: this.id, action: "increment" });
  }

  decrement(amount = 1) {
    this.count -= parseInt(amount);
    process.parentPort.postMessage({ nodeId: this.id, action: "decrement" });
  }

  reset() {
    this.count = 0;
    process.parentPort.postMessage({ nodeId: this.id, action: "reset" });
  }

  set(value) {
    this.count = parseInt(value);
    process.parentPort.postMessage({ nodeId: this.id, action: "set" });
  }
}
`
}


function defineInterval() {
  return `
class Interval extends EventEmitter {
  #minIntervalInMs = 500;
  #value = 0;

  set value(value) {
    this.#value = value;
    this.emit("change", value);
    process.parentPort.postMessage({ nodeId: this.id, action: "change", value: this.value });
  }

  get value() {
    return this.#value;
  }

  constructor(options) {
    super();

    this.id = options.id;

    setInterval(() => {
      this.value = performance.now()
    }, this.#interval(options.interval));
  }

  #interval(interval) {
    const parsed = parseInt(interval);
    const isNumber = !isNaN(parsed);

    if (!isNumber) {
      return this.#minIntervalInMs;
    }

    return Math.max(this.#minIntervalInMs, parsed);
  }
}
`
}
