import { Edge, Node } from "@xyflow/react";
import { NodeType } from "../render/components/react-flow/ReactFlowCanvas";

const defintions: Record<NodeType, () => string> = {
  Button: defineButton,
  Counter: defineCounter,
  Interval: defineInterval,
  Led: defineLed,
  Figma: defineFigma
}

export function generateCode(nodes: Node[], edges: Edge[]) {
  let code = `
/*
 * This code was generated by Figma hardware bridge.
 *
 * No warranty is provided.
 */
`

  code += addImports()

  let innerCode = ``

  innerCode += addBoard()

  const boardListners = ["error", "fail", "warn", "exit", "close", "info"]
  boardListners.forEach((listener) => {
    innerCode += addBoardListener(listener)
  })

  innerCode += addBoardListener("ready", false)
  nodes.forEach((node) => {
    innerCode += `  ${createNode(node)}`
    innerCode += addEnter()
  })
  innerCode += addEnter()

  innerCode += `  const nodes = [${nodes.map(node => `{ id: "${node.type}_${node.id}", variable: ${node.type}_${node.id} }`)}]`
  innerCode += addEnter()
  innerCode += addEnter()

  const nodesWithActionListener = nodes.filter(node => edges.some((edge) => edge.source === node.id))

  nodesWithActionListener.forEach((node) => {
    const actions = edges.filter((edge) => edge.source === node.id);

    const actionsGroupedByHandle = actions.reduce(
      (acc, action) => {
        if (!acc[action.sourceHandle]) {
          acc[action.sourceHandle] = [];
        }

        acc[action.sourceHandle].push(action);

        return acc;
      },
      {} as Record<string, Edge[]>,
    );

    Object.entries(actionsGroupedByHandle).forEach(([action, edges]) => {
      innerCode += `  ${node.type}_${node.id}.on("${action}", () => {`
      innerCode += addEnter()

      edges.forEach((edge) => {
        const targetNode = nodes.find((node) => node.id === edge.target);
        const value = ["set", "red", "green", "blue", "opacity"].includes(edge.targetHandle) ? `${node.type}_${node.id}.value` : undefined
        // TODO: add support for increment and decrement bigger than 1
        innerCode += `    ${targetNode?.type}_${targetNode?.id}.${edge.targetHandle}(${value});`
        innerCode += addEnter()
      })

      innerCode += `  }); // ${node.type}_${node.id} - ${action}`
      innerCode += addEnter()
      innerCode += addEnter()
    })
  })

  innerCode += addNodeProcessListener()
  innerCode += `}); // board - ready`

  code += wrapInTryCatch(innerCode)

  Object.keys(defintions).forEach((type) => {
    if (!nodes.find(node => node.type === type)) {
      return
    }

    code += addEnter()
    code += defintions[type as NodeType]()
  })

  return code
}

function addEnter() {
  return `
`
}

function addImports() {
  return `
const EventEmitter = require("events");
const JohnnyFive = require("johnny-five");
const log = require("electron-log/node");
`
}

function addBoard() {
  return `
const board = new JohnnyFive.Board({
  repl: false,
  debug: false,
});
`
}

function addBoardListener(type: string, selfClosing = true) {
  return `
board.on("${type}", (event) => {
  log.warn("board ${type}", { event });
  process.parentPort.postMessage({ type: "${type}", message: event?.message });
${selfClosing ? `}); // board - ${type}` : ``}
`
}

function addNodeProcessListener() {
  let code = `
process.parentPort.on('message', (e) => {`

  let innerCode = ``

  innerCode += "const node = nodes.find((node) => node.id === \`${e.data.nodeType}_${e.data.nodeId}\`);"
  innerCode += addEnter()
  innerCode += "node?.variable.setExternal(e.data.value)"

  code += wrapInTryCatch(innerCode)

  code += `
}); // process.parentPort.on - 'message'`
  code += addEnter()
  return code
}

function wrapInTryCatch(code: string) {
  return `
try {
  ${code}
} catch(error) {
  log.error("something went wrong", { error });
}
`
}

function createNode(node: Node) {
  node.data.id = node.id;

  switch (node.type as NodeType) {
    case "Button":
    case "Led":
    case "Counter":
    case "Interval":
    case "Figma":
      return `const ${node.type}_${node.id} = new ${node.type}(${JSON.stringify(node.data)});`;
    default:
      console.warn(`Unknown node type: ${node.type}`);
      return ``;
  }
}

function defineButton() {
  return `
class Button extends JohnnyFive.Button {
  get value() {
    return this.value;
  }

  constructor(options) {
    super(options);

    this.on("up", this.#postMessage.bind(this, "up"));
    this.on("down", this.#postMessage.bind(this, "down"));
    this.on("hold", this.#postMessage.bind(this, "hold"));
    this.on("change", this.#postMessage.bind(this, "change"));
  }

  #postMessage(action) {
    if (action !== "change") {
      this.emit("change", this.value);
    }

    process.parentPort.postMessage({ nodeId: this.id, action, value: this.value });
  }
}
`
}

function defineLed() {
  return `
class Led extends JohnnyFive.Led {
  #eventEmitter = new EventEmitter();
  #value = null

  constructor(options) {
    super(options);

    this.#eventEmitter.on("change", () => {
      process.parentPort.postMessage({ nodeId: this.id, action: "change", value: this.value });
    })

    setInterval(() => {
      if(this.#value !== null && this.#value !== this.value) {
        this.#eventEmitter.emit("change");
      }
      this.#value = this.value;
    }, 7)
  }

  // Highjack the on method
  // to allow for a custom actions
  on(action, callback) {
    if (!action) {
      super.on();
      return;
    }

    this.#eventEmitter.on(action, callback);
  }
}
`
}

function defineCounter() {
  return `
class Counter extends EventEmitter {
  #value = 0;

  constructor(options) {
    super();

    this.on("change", () => {
      process.parentPort.postMessage({ nodeId: options.id, action: "change", value: this.value });
    })
  }

  set value(value) {
    this.#value = parseInt(value);
    this.emit("change", this.value);
  }

  get value() {
    return this.#value;
  }

  increment(amount = 1) {
    this.value += amount;
  }

  decrement(amount = 1) {
    this.value -= amount;
  }

  reset() {
    this.value = 0;
  }

  set(value) {
    this.value = value;
  }
}
`
}


function defineInterval() {
  return `
class Interval extends EventEmitter {
  #minIntervalInMs = 500;
  #value = 0;

  constructor(options) {
    super();

    this.on("change", () => {
      process.parentPort.postMessage({ nodeId: options.id, action: "change", value: this.value });
    });

    setInterval(() => {
      this.value = performance.now()
    }, this.#interval(options.interval));
  }

  set value(value) {
    this.#value = value;
    this.emit("change", value);
  }

  get value() {
    return this.#value;
  }

  #interval(interval) {
    const parsed = parseInt(interval);
    const isNumber = !isNaN(parsed);

    if (!isNumber) {
      return this.#minIntervalInMs;
    }

    return Math.max(this.#minIntervalInMs, parsed);
  }
}
`
}

function defineFigma() {
  return `
class Figma extends EventEmitter {
  #value = null;
  #defaultRGBA = { r: 0, g: 0, b: 0, a: 0 }

  constructor(options) {
    super();

    this.on("change", () => {
      process.parentPort.postMessage({ nodeId: options.id, action: "change", value: this.value });
    });
  }

  set value(value) {
    this.#value = value;
    this.emit("change", value);
  }

  get value() {
    return this.#value;
  }

  increment(amount = 1) {
    this.value += amount;
  }

  decrement(amount = 1) {
    this.value -= amount;
  }

  true() {
    this.value = true;
  }

  false() {
    this.value = false;
  }

  toggle() {
    this.value = !this.value;
  }

  set(value) {
    this.value = value;
  }

  setExternal(value) {
    this.#value = value;
  }

  red(value) {
    this.value = { ...this.#defaultRGBA, ...this.#value, r: Math.min(1, value / 255) };
  }

  green(value) {
    this.value = { ...this.#defaultRGBA, ...this.#value, g: Math.min(1, value / 255) };
  }

  blue(value) {
    this.value = { ...this.#defaultRGBA, ...this.#value, b: Math.min(1, value / 255) };
  }

  opacity(value) {
    this.value = { ...this.#defaultRGBA, ...this.#value, a: Math.min(1, value / 100) };
  }
}
  `
}
